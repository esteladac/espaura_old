/**
 * ESPAura Firmware v1.0.0
 * 
 * A modular and efficient firmware for an ESP-based Ambilight system.
 * Designed for compatibility with HyperHDR via the Adalight protocol.
 * Allows manual configuration through serial commands and future WiFi support.
 * 
 * Developed by Esteladac | ESPAura Project
 * 
 * Used resources: 
 * - FastLED library for controlling LED strips
 * - IRremoteESP8266 library for IR remote control
 * - Using adalight from : https://github.com/Wifsimster/adalight_ws2812 (Thank you for allowing me to use your code)
 * - Using HyperHDR for Adalight protocol reference
 * - Using WLED Code to have some ideas how to code, I'm not copying it, just using it as a reference.
 * - ChatGPT for ideas suggestions and effect code generation, the code is not generated by it, it's written by me.
 * - Comments for all the file written by Github Copilot.
 * 
 * Functionalities:
 * - Adalight mode for HyperHDR compatibility
 * - Configuration mode for setting LED count, max current, and max framerate
 * - Manual mode for direct LED control
 * - IR remote control support for switching modes
 * - EEPROM storage for configuration persistence
 * - Serial communication for configuration and debugging
 * - Built-in LED for status indication
 * - Improved error handling and logging
 * - Modular design for easy expansion and customization
 * 
 * Future improvements:
 * - WiFi support for remote configuration and control
 * - Additional effects and animations for LEDs
 * - User-friendly configuration interface
 * - Support for multiple LED types and configurations
 * - Integration with home automation systems
 * - Customizable presets for different lighting scenarios
 * - Support for different communication protocols (e.g., MQTT, HTTP API)
 * - Enhanced performance and efficiency
 * 
 * License:
 * Copyright (c) 2025 Esteladac - All Rights Reserved https://shvps.xyz/espaura/license.txt
 * 
*/

// ----------------------- //
// Disable functionalities //
// ----------------------- //

// #define DISABLE_IR
// #define DISABLE_EEcPROM
// #define DISABLE_WIFI
#define DISABLE_MQTT

// ------------- //
// Configuration //
// ------------- //

// Firmware infos

#define ESPAURA_VERSION "0.3.0" // Version of the firmware

// Firmware settings

#define LOG_LEVEL 3 // Log level (0 = no logs, 1 = info, 2 = warning, 3 = debug) warning: 0 level delete errors !

// Configuration 

#define SERIAL_RATE 921600 // Serial communication rate
#define MAX_SERIAL_WORDS 10 // Maximum number of words in a command
#define DEFAULT_NUM_LEDS 30 // Default number of LEDs
#define DEFAULT_MILLIAMPS 850 // Default max current in mA
#define DEFAULT_FRAMERATE 60 // Default max frames per second
#define MAX_LED_COUNT 800 // Maximum number of LEDs supported

// EEPROM settings

#define EEPROM_SIZE 512 // Size of the EEPROM in bytes

// Pin definitions

#define LED_PIN 15
#define INFO_LED_PIN 2
#define ACTION_BUTTON_PIN 13
#define IR_PIN 12

// --------- //
// Libraries //
// --------- //

#include <Arduino.h> // Arduino core library
#include <FastLED.h> // FastLED library for controlling LED strips
#ifndef DISABLE_EEPROM
    #include <EEPROM.h> // EEPROM library for storing configuration
    #define EEPROM_ENABLED true // Enable EEPROM storage
#else
    #define EEPROM_ENABLED false // Disable EEPROM storage
#endif
#ifndef DISABLE_IR
  #include <IRremoteESP8266.h>
  #include <IRrecv.h>
  #include <IRutils.h>
#endif
#ifndef DISABLE_WIFI
  #include <ESP8266WiFi.h> // WiFi library for ESP8266
  #include <ESP8266WebServer.h> // Web server library for ESP8266
  #include <ArduinoJson.h> // JSON library for ESP8266
#endif
#ifndef DISABLE_FS
  #include <LittleFS.h> // File system library for ESP8266
#endif
#ifndef DISABLE_MQTT
  #include <PubSubClient.h> // MQTT library for ESP8266
  #define MQTT_MAX_CONNECTIONS 5 // Maximum number of MQTT connections
#endif

// ----------------------- //
// Constants and variables //
// ----------------------- //

#ifndef DISABLE_IR
    IRrecv irrecv(IR_PIN);
    decode_results results;
#endif

const char* DEFAULT_SSID = ""; // WiFi SSID
const char* DEFAULT_PSK = ""; // WiFi password
const char* DEFAULT_MQTT_SERVER = "192.168.1.100"; // MQTT server address
const char* DEFAULT_MQTT_USER = "root"; // MQTT username
const char* DEFAULT_MQTT_PASSWORD = ""; // MQTT password

const uint8_t CURRENT_VERSION = 00000003; // Current version of the firmware in binary format

uint8_t mode = 0; // Current mode (0 = Adalight, 1 = Config, 3 = Manual)
uint8_t lastMode = 3; // Last mode used

int lastActionButtonState = LOW; // Last state of the action button

bool EEPROM_ERROR = false; // Flag to indicate if there was an EEPROM error

CRGB leds[MAX_LED_COUNT]; // Array to hold the LED colors

uint8_t prefix[] = {'A', 'd', 'a'}, hi, lo, chk, i; // Prefix for Adalight protocol

uint8_t brightness = 255; // Valeur initiale, à adapter selon ton projet
uint8_t brightnessStep = 26; // Équivalent de 10% sur 255
uint8_t brightnessMin = 16;
uint8_t brightnessMax = 150;

bool ledPower = true;

int currentEffect = 0; // Current effect index

int tmpvar = 0; // Temporary variable for calculations

bool firstRun = true; // Flag to indicate if it's the first run of the program

#ifndef DISABLE_WIFI
    ESP8266WebServer server(80); // Web server object
#endif

#ifndef DISABLE_FS
    const bool fsEnabled = false; // Initialize the file system
#else
    const bool fsEnabled = true;// Initialize the file system
#endif

// --------- //
// Functions //
// --------- //

// Config values and functions

struct configuration {
    int LED_COUNT; // Number of LEDs
    int MILLIAMPS; // Max current in mA
    uint8_t MAX_FPS; // Max frames per second
    char SSID[32]; // WiFi SSID
    char PSK[64]; // WiFi password
    char MQTT_SERVER[32]; // MQTT server address
    char MQTT_USER[32]; // MQTT username
    char MQTT_PASSWORD[32]; // MQTT password
};
configuration config; // Configuration object

// Logging functions

struct logFunctions {
    void info(String message) {
        if (LOG_LEVEL >= 1) {
            Serial.println("[INFO] " + message);
        }
    }
    void error(String message) {
        if (LOG_LEVEL >= 1) {
            Serial.println("[ERROR] " + message);
        }
    }
    void warn(String message) {
        if (LOG_LEVEL >= 2) {
            Serial.println("[WARNING] " + message);
        }
    }
    void debug(String message) {
        if (LOG_LEVEL >= 3) {
            Serial.println("[DEBUG] " + message);
        }
    }
};
logFunctions logg; // Logging object

struct eepromFunctions {
    void save() {
        logg.debug("EEPROM: Saving configuration with size " + String(sizeof(config)) + " bytes");
        EEPROM.write(0, 0xAA); // Write a marker to indicate EEPROM is not empty
        EEPROM.put(1, CURRENT_VERSION); // Write the current version to EEPROM
        EEPROM.put(2, config); // Save the config struct to EEPROM
        EEPROM.commit(); // Commit changes to EEPROM
        logg.debug("EEPROM: Values saved to EEPROM");
        logg.warn("System: Restarting ESP to apply changes...");
        ESP.restart(); // Restart the ESP to apply changes
    }
    void load() {
        EEPROM.get(2, config); // Read the config struct from EEPROM
        logg.debug("EEPROM: Values read from EEPROM");
        logg.debug("EEPROM: LED Count: " + String(config.LED_COUNT) + " LEDs");
        logg.debug("EEPROM: Max Current: " + String(config.MILLIAMPS) + " mA");
        #ifndef DISABLE_WIFI
            logg.debug("EEPROM: WiFi SSID: " + String(config.SSID));
            // logg.debug("EEPROM: WiFi PSK: " + String(config.PSK));
        #endif
        #ifndef DISABLE_MQTT
            logg.debug("EEPROM: MQTT Server: " + String(config.MQTT_SERVER));
            logg.debug("EEPROM: MQTT User: " + String(config.MQTT_USER));
            // logg.debug("EEPROM: MQTT Password: " + String(config.MQTT_PASSWORD));
        #endif
    }
    void init() {
        EEPROM.begin(EEPROM_SIZE); // Initialize EEPROM
        logg.debug("EEPROM: Initialized with size " + String(EEPROM_SIZE) + " bytes");
        if (EEPROM_ENABLED) {
            if (EEPROM.read(0) == 0xFF) {
                logg.debug("EEPROM: empty, setting default values...");
                config.LED_COUNT = DEFAULT_NUM_LEDS;
                config.MILLIAMPS = DEFAULT_MILLIAMPS;
                config.MAX_FPS = DEFAULT_FRAMERATE;
                strncpy(config.SSID, DEFAULT_SSID, sizeof(config.SSID));
                strncpy(config.PSK, DEFAULT_PSK, sizeof(config.PSK));
                strncpy(config.MQTT_SERVER, DEFAULT_MQTT_SERVER, sizeof(config.MQTT_SERVER));
                strncpy(config.MQTT_USER, DEFAULT_MQTT_USER, sizeof(config.MQTT_USER));
                strncpy(config.MQTT_PASSWORD, DEFAULT_MQTT_PASSWORD, sizeof(config.MQTT_PASSWORD));
                save();
            } else if (EEPROM.read(0) == 0xAA) {
                if (EEPROM.read(1) == CURRENT_VERSION) {
                    logg.debug("EEPROM: not empty, reading values...");
                    load();
                } else {
                    logg.error("EEPROM: Invalid or outdated EEPROM data, setting default values...");
                    EEPROM_ERROR = true;
                    config.LED_COUNT = DEFAULT_NUM_LEDS;
                    config.MILLIAMPS = DEFAULT_MILLIAMPS;
                    config.MAX_FPS = DEFAULT_FRAMERATE;
                    strncpy(config.SSID, DEFAULT_SSID, sizeof(config.SSID));
                    strncpy(config.PSK, DEFAULT_PSK, sizeof(config.PSK));
                    strncpy(config.MQTT_SERVER, DEFAULT_MQTT_SERVER, sizeof(config.MQTT_SERVER));
                    strncpy(config.MQTT_USER, DEFAULT_MQTT_USER, sizeof(config.MQTT_USER));
                    strncpy(config.MQTT_PASSWORD, DEFAULT_MQTT_PASSWORD, sizeof(config.MQTT_PASSWORD));
                    save();
                }
            }
        } else {
            logg.warn("EEPROM: disabled, using default values...");
            config.LED_COUNT = DEFAULT_NUM_LEDS;
            config.MILLIAMPS = DEFAULT_MILLIAMPS;
            config.MAX_FPS = DEFAULT_FRAMERATE;
            strncpy(config.SSID, DEFAULT_SSID, sizeof(config.SSID));
            strncpy(config.PSK, DEFAULT_PSK, sizeof(config.PSK));
            strncpy(config.MQTT_SERVER, DEFAULT_MQTT_SERVER, sizeof(config.MQTT_SERVER));
            strncpy(config.MQTT_USER, DEFAULT_MQTT_USER, sizeof(config.MQTT_USER));
            strncpy(config.MQTT_PASSWORD, DEFAULT_MQTT_PASSWORD, sizeof(config.MQTT_PASSWORD));
        }
    }
    void clear() {
        logg.warn("EEPROM: Clearing EEPROM...");
        for (int i = 0; i < EEPROM_SIZE; i++) {
            EEPROM.write(i, 0xFF);
        }
        EEPROM.commit();
        bool isCleared = true;
        for (int i = 0; i < EEPROM_SIZE; i++) {
            if (EEPROM.read(i) != 0xFF) {
                isCleared = false;
                break;
            }
        }
        if (isCleared) {
            logg.debug("EEPROM: Cleared successfully, resetting ESP...");
            delay(3000);
            ESP.restart();
        } else {
            logg.error("EEPROM: Failed to clear properly!");
        }
    }
};

eepromFunctions eeprom; // EEPROM object

#ifndef DISABLE_FS

struct fsFunctions {
    void init() {
        if (!LittleFS.begin()) { // Initialize the file system
            logg.error("FS: Failed to mount file system");
            return;
        }
        logg.debug("FS: File system mounted successfully");
        
        Dir dir = LittleFS.openDir("/");
        while (dir.next()) {
            logg.debug("Detected file:" + dir.fileName());
        }
    }
    void listFiles() {
        Dir dir = LittleFS.openDir("/"); // Open the root directory
        while (dir.next()) { // Iterate through files in the directory
            String fileName = dir.fileName(); // Get the file name
            size_t fileSize = dir.fileSize(); // Get the file size
            logg.info("FS: File: " + fileName + ", Size: " + String(fileSize) + " bytes");
        }
    }
    void readFile(String fileName) {
        File file = LittleFS.open(fileName, "r"); // Open the file for reading
        if (!file) {
            logg.error("FS: Failed to open file for reading: " + fileName);
            return;
        }
        logg.info("FS: Reading file: " + fileName);
        String fileContent = "";
        while (file.available()) {
            fileContent += (char)file.read();
            // Pour éviter de saturer la RAM, on logge par blocs de 128 caractères
            if (fileContent.length() >= 128) {
                logg.info("FS: " + fileContent);
                fileContent = "";
            }
        }
        if (fileContent.length() > 0) {
            logg.info("FS: " + fileContent);
        }
        file.close(); // Close the file
    }
    void writeFile(String fileName, String content) {
        File file = LittleFS.open(fileName, "w"); // Open the file for writing
        if (!file) {
            logg.error("FS: Failed to open file for writing: " + fileName);
            return;
        }
        logg.info("FS: Writing to file: " + fileName);
        file.print(content); // Write content to the file
        file.close(); // Close the file
    }
};

fsFunctions lfs; // File system object

#endif

// Led functions

struct ledStruct {
    struct colorStruct {
        uint8_t r, g, b; // RGB color values
    };
    colorStruct color; // Color object
    void init() {
        FastLED.addLeds<NEOPIXEL, LED_PIN>(leds, config.LED_COUNT); // Initialize the LED strip
        FastLED.setMaxRefreshRate(config.MAX_FPS); // Set max refresh rate
        FastLED.setMaxPowerInVoltsAndMilliamps(5, config.MILLIAMPS); // Set max power in volts and milliamps
    }
    void on() {
        ledPower = true;
        FastLED.setBrightness(brightness);
        FastLED.show();
    }
    void off() {
        ledPower = false;
        FastLED.setBrightness(0);
        FastLED.show();
    }
    void setBrightness(uint8_t level) {
        // Clamp brightness between brightnessMin and brightnessMax
        if (level < brightnessMin) {
            brightness = brightnessMin;
        } else if (level > brightnessMax) {
            brightness = brightnessMax;
        } else {
            brightness = level;
        }
        FastLED.setBrightness(ledPower ? brightness : 0);
        FastLED.show();
        logg.info("LEDs: Brightness set to " + String(brightness));
    }
    void setColor(int r, int g, int b) {
        color.r = r;
        color.g = g;
        color.b = b;
        if (mode == 2) {
            for (int i = 0; i < config.LED_COUNT; i++) {
                leds[i] = CRGB(color.r, color.g, color.b);
            }
            if (ledPower) {
                FastLED.show();
            }
            logg.debug("LEDs: Color set to R:" + String(color.r) + " G:" + String(color.g) + " B:" + String(color.b));
        } else {
            logg.warn("LEDs: Cannot set color in current mode");
        }
    }
};

ledStruct led; // LED object

#ifndef DISABLE_WIFI
struct wifiStruct {
    enum State { DISCONNECTED, CONNECTING, CONNECTED };
    State wifiState = DISCONNECTED;

    unsigned long connectStartTime = 0;
    const unsigned long timeout = 15000; // 15 seconds

    void init() {
        WiFi.mode(WIFI_STA);
        startConnection();
    }

    void startConnection() {
        WiFi.begin(config.SSID, config.PSK);
        connectStartTime = millis();
        wifiState = CONNECTING;
        logg.info("WiFi: Attempting to connect to " + String(config.SSID) + "...");
    }

    void loop() {
        switch (wifiState) {
            case CONNECTING:
                if (WiFi.status() == WL_CONNECTED) {
                    wifiState = CONNECTED;
                    logg.info("WiFi: Connected to " + String(config.SSID) + " with IP: " + WiFi.localIP().toString());
                    logg.info("WiFi: RSSI = " + String(WiFi.RSSI()) + " dBm");
                } else if (millis() - connectStartTime >= timeout) {
                    wifiState = DISCONNECTED;
    
                    String reason;
                    switch (WiFi.status()) {
                        case WL_NO_SSID_AVAIL:
                            reason = "SSID not found";
                            break;
                        case WL_CONNECT_FAILED:
                            reason = "Connection failed (wrong password?)";
                            break;
                        case WL_IDLE_STATUS:
                            reason = "Idle (not started)";
                            break;
                        case WL_DISCONNECTED:
                            reason = "Disconnected";
                            break;
                        default:
                            reason = "Unknown error";
                            break;
                    }
    
                    logg.error("WiFi: Failed to connect within timeout. Reason: " + reason);
                }
                break;
    
            case CONNECTED:
                if (WiFi.status() != WL_CONNECTED) {
                    logg.warn("WiFi: Lost connection, reconnecting...");
                    WiFi.disconnect();
                    startConnection();
                }
                break;
    
            case DISCONNECTED:
                // Optional: Retry after delay or leave it to manual reconnection
                break;
        }
    }
};

wifiStruct wifi; // WiFi object
#endif

#ifndef DISABLE_MQTT
WiFiClient espClient; // Ajouté pour MQTT
struct mqttStruct {
    PubSubClient mqttClient;
    unsigned long lastDiscoverySent = 0;
    const char* discoveryTopic = "homeassistant/light/espaura/config";
    const char* stateTopic = "homeassistant/light/espaura/state";
    const char* commandTopic = "homeassistant/light/espaura/set";
    mqttStruct() : mqttClient(espClient) {} // Initialisation correcte du client MQTT
    void init() {
        mqttClient.setServer(config.MQTT_SERVER, 1883);
        mqttClient.setCallback([this](char* topic, byte* payload, unsigned int length) {
            handleMqttMessage(topic, payload, length);
        });
        logg.info("MQTT: Initialized with server " + String(config.MQTT_SERVER));
    }
    void connect() {
        if (mqttClient.connect("ESP8266Client", config.MQTT_USER, config.MQTT_PASSWORD)) {
            logg.info("MQTT: Connected to " + String(config.MQTT_SERVER));
            mqttClient.subscribe(commandTopic);
            sendDiscovery();
            publishState();
        } else {
            logg.error("MQTT: Failed to connect to " + String(config.MQTT_SERVER));
        }
    }
    void loop() {
        if (!mqttClient.connected()) {
            connect();
        }
        mqttClient.loop();
        // Resend discovery every 10 minutes
        if (millis() - lastDiscoverySent > 600000) {
            sendDiscovery();
        }
    }
    void handleMqttMessage(char* topic, byte* payload, unsigned int length) {
        StaticJsonDocument<256> doc;
        DeserializationError error = deserializeJson(doc, payload, length);
        if (error) return;
        if (doc["state"].is<const char*>()) {
            String state = doc["state"].as<String>();
            if (state == "ON") led.on();
            else if (state == "OFF") led.off();
        }
        if (doc["brightness"].is<int>()) {
            int bri = doc["brightness"];
            led.setBrightness(bri);
        }
        if (doc["color"].is<JsonObject>()) {
            int r = doc["color"]["r"];
            int g = doc["color"]["g"];
            int b = doc["color"]["b"];
            led.setColor(r, g, b);
        }
        publishState();
    }
    void publishState() {
        StaticJsonDocument<256> doc;
        doc["state"] = ledPower ? "ON" : "OFF";
        doc["brightness"] = brightness;
        JsonObject color = doc["color"].to<JsonObject>();
        color["r"] = led.color.r;
        color["g"] = led.color.g;
        color["b"] = led.color.b;
        char buf[256];
        size_t n = serializeJson(doc, buf);
        mqttClient.publish(stateTopic, (const uint8_t*)buf, n);
    }
    void sendDiscovery() {
        StaticJsonDocument<512> doc;
        doc["name"] = "ESPAura LED";
        doc["unique_id"] = "espaura_led";
        doc["schema"] = "json";
        doc["state_topic"] = stateTopic;
        doc["command_topic"] = commandTopic;
        doc["brightness"] = true;
        doc["color_mode"] = true;
        doc["supported_color_modes"] = JsonArray();
        JsonArray colorModes = doc["supported_color_modes"].to<JsonArray>();
        colorModes.add("rgb");
        doc["platform"] = "mqtt";
        doc["qos"] = 0;
        doc["payload_on"] = "ON";
        doc["payload_off"] = "OFF";
        doc["retain"] = false;
        // Home Assistant device info
        JsonObject device = doc.createNestedObject("device");
        JsonArray identifiers = device.createNestedArray("identifiers");
        identifiers.add("espaura_led");
        device["name"] = "ESPAura LED";
        device["manufacturer"] = "ESPAura";
        device["model"] = "ESP8266";
        device["sw_version"] = ESPAURA_VERSION;
        char buf[512];
        size_t n = serializeJson(doc, buf);
        mqttClient.publish(discoveryTopic, (const uint8_t*)buf, n, true);
        lastDiscoverySent = millis();
        logg.info("MQTT: Sent Home Assistant discovery");
    }
};
mqttStruct mqtt;
#endif


// Effects functions


struct effects {
    unsigned long rainbowSwirl_previousMillis = 0;
    const unsigned long rainbowSwirl_interval = 20;  // Update every 20ms for smooth effect
    void rainbowSwirl() {
        static int rainbowSwirl_hueShift = 0;    // Start hue value for rainbow
        static int rainbowSwirl_swirlSpeed = 1; // Speed of the swirl
        unsigned long rainbowSwirl_currentMillis = millis();
      
        // Only update the LED colors every 'interval' milliseconds
        if (rainbowSwirl_currentMillis - rainbowSwirl_previousMillis >= rainbowSwirl_interval) {
          rainbowSwirl_previousMillis = rainbowSwirl_currentMillis;
      
          // Create the rainbow swirl effect
          for (int i = 0; i < config.LED_COUNT; i++) {
            // Calculate the hue based on position and time for a swirling effect
            int hue = (rainbowSwirl_hueShift + (i * 256 / config.LED_COUNT)) % 256;
            leds[i] = CHSV(hue, 255, 255); // Set the color of each LED based on hue
          }
      
          // Show the updated LED colors
          FastLED.show();
          
          // Adjust hueShift to make the swirl move
          rainbowSwirl_hueShift += rainbowSwirl_swirlSpeed;
        }
      }
};

effects effect; // Effects object

struct modesHandling {
    void catchSerial() {
        if (mode != lastMode) {
            lastMode = mode; // Update the last mode
            logg.debug("Serial: Switching to Config mode...");
        }
        while (Serial.available() > 0) {
            char incomingByte = Serial.read(); // Read the incoming byte
            Serial.print("Received: ");
            Serial.println(incomingByte); // Print the received byte
        }
    }
    unsigned long serialTimeout = 100; // Temps d'attente max en ms
    bool waitForSerialData(int bytesNeeded, unsigned long timeout) {
    unsigned long startTime = millis();
    while (Serial.available() < bytesNeeded) {
        if (millis() - startTime > timeout) {
        return false; // Timeout atteint
        }
        yield(); // Laisse l'ESP faire d'autres tâches (utile pour ESP8266/ESP32)
    }
    return true;
    }
    void commandHandler() {
        if (Serial.available() > 0) {  
            String command = Serial.readStringUntil('\n'); // Read command until newline
            command.trim(); // Remove whitespace
    
            if (command.length() == 0) return; // Ignore empty input
    
            int firstSpace = command.indexOf(' ');
            String cmd = (firstSpace != -1) ? command.substring(0, firstSpace) : command;
            cmd.toLowerCase(); // Normalize only the command
    
            String args = (firstSpace != -1) ? command.substring(firstSpace + 1) : "";
    
            if (cmd == "set") {
                int secondSpace = args.indexOf(' ');
                if (secondSpace == -1) {
                    logg.warn("Serial: Invalid set command format");
                    return;
                }
    
                String subCmd = args.substring(0, secondSpace);
                subCmd.toLowerCase(); // Normalize only subcommand
                String subArgs = args.substring(secondSpace + 1);
                int value = subArgs.toInt(); // Used only for numeric fields
    
                if (subCmd == "led") {
                    if (value > MAX_LED_COUNT) {
                        logg.warn("Serial: LED count exceeds maximum of " + String(MAX_LED_COUNT) + ", setting to " + String(MAX_LED_COUNT));
                        config.LED_COUNT = MAX_LED_COUNT;
                    } else {
                        logg.info("Serial: Setting LED count to " + String(value));
                        config.LED_COUNT = value;
                    }
    
                } else if (subCmd == "color") {
                    for (int i = 0; i < config.LED_COUNT; i++) {
                        leds[i] = CRGB(value);
                    }
                    FastLED.show();
    
                } else if (subCmd == "ma") {
                    logg.info("Serial: Setting max consumption to " + String(value) + " mA");
                    config.MILLIAMPS = value;
    
                } else if (subCmd == "fps") {
                    logg.info("Serial: Setting max framerate to " + String(value) + " fps");
                    if (value > 60) {
                        logg.warn("Serial: FPS value exceeds 60, the controller may encounter issues!");
                    }
                    config.MAX_FPS = value;
    
                } else if (subCmd == "ssid") {
                    if (subArgs.length() >= sizeof(config.SSID)) {
                        logg.warn("Serial: SSID too long, truncating to " + String(sizeof(config.SSID) - 1));
                        subArgs = subArgs.substring(0, sizeof(config.SSID) - 1);
                    }
                    strncpy(config.SSID, subArgs.c_str(), sizeof(config.SSID));
                    config.SSID[sizeof(config.SSID) - 1] = '\0'; // Ensure null-termination
                    logg.info("Serial: Setting WiFi SSID to " + String(config.SSID));
    
                } else if (subCmd == "psk") {
                    if (subArgs.length() >= sizeof(config.PSK)) {
                        logg.warn("Serial: PSK too long, truncating to " + String(sizeof(config.PSK) - 1));
                        subArgs = subArgs.substring(0, sizeof(config.PSK) - 1);
                    }
                    strncpy(config.PSK, subArgs.c_str(), sizeof(config.PSK));
                    config.PSK[sizeof(config.PSK) - 1] = '\0'; // Ensure null-termination
                    logg.info("Serial: Setting WiFi PSK to " + String(config.PSK));
    
                } else {
                    logg.warn("Serial: Unknown subcommand for 'set': " + subCmd);
                }
    
            } else if (cmd == "info") {
                logg.info("LED count: " + String(config.LED_COUNT));
                logg.info("Max FPS: " + String(config.MAX_FPS));
                logg.info("Current fps: " + String(FastLED.getFPS()));
                logg.info("Max current: " + String(config.MILLIAMPS) + " mA");
                logg.info("Max power: " + String(config.MILLIAMPS * 5 / 1000.0) + " W");
                logg.info("WiFi SSID: " + String(config.SSID));
            } else if (cmd == "save") {
                logg.info("Serial: Saving configuration...");
                eeprom.save();
    
            } else if (cmd == "clear") {
                eeprom.clear();
    
            } else {
                logg.debug("Serial: Unknown command: " + command + ". Use \"help\" for list of commands.");
            }
        }
    }
    void adalight() {
        static char configBuffer[7] = {0}; // Buffer pour stocker "config"

        // Vérifier si "config" est tapé dans le port série
        while (Serial.available()) {
          char c = Serial.read();
      
          // Décalage du buffer et ajout du nouveau caractère
          for (uint8_t j = 0; j < 5; j++) {
            configBuffer[j] = configBuffer[j + 1];
          }
          configBuffer[5] = c;
          configBuffer[6] = '\0';
      
          // Vérifier si "config" est dans le buffer
          if (strcmp(configBuffer, "config") == 0) {
            mode = 1;
            return;
          }
        }
      
        for (i = 0; i < sizeof prefix; ++i) {
          waitLoop:
          if (!waitForSerialData(1, serialTimeout)) return;
          if (prefix[i] == Serial.read()) continue;
          i = 0;
          goto waitLoop;
        }
      
        if (!waitForSerialData(3, serialTimeout)) return;
        hi = Serial.read();
        lo = Serial.read();
        chk = Serial.read();
      
        if (chk != (hi ^ lo ^ 0x55)) {
          i = 0;
          goto waitLoop;
        }
      
        memset(leds, 0, config.LED_COUNT * sizeof(struct CRGB));
      
        for (uint8_t i = 0; i < config.LED_COUNT; i++) {
          if (!waitForSerialData(3, serialTimeout)) return;
          byte r = Serial.read();
          byte g = Serial.read();
          byte b = Serial.read();
          leds[i] = CRGB(r, g, b);
        }
        FastLED.show();
    }
    void manual() {
        if (currentEffect == 0) {
            FastLED.show(); // Update the LED strip
        } else if (currentEffect == 1) {
            effect.rainbowSwirl(); // Call the rainbow swirl effect
        } else if (currentEffect == 2) {
            // Effect 2 code here
        } else if (currentEffect == 3) {
            // Effect 3 code here
        } else if (currentEffect == 4) {
            // Effect 4 code here
        } else if (currentEffect == 5) {
            // Effect 5 code here
        } else if (currentEffect == 6) {
            // Effect 6 code here
        } else if (currentEffect == 7) {
            // Effect 7 code here
        } else if (currentEffect == 8) {
            // Effect 8 code here
        } else if (currentEffect == 9) {
            // Effect 9 code here
        }
    }
    void loop() {
        int currentButtonState = digitalRead(ACTION_BUTTON_PIN);
        if (lastActionButtonState == HIGH && currentButtonState == LOW) {
            logg.debug("Button: Action button pressed, switching mode...");
        
            // Cycle between modes
            if (mode == 0) {
                mode = 1;
            } else if (mode == 1) {
                mode = 0;
            } else if (mode == 2) {
                mode = 1;
            }
        }
        lastActionButtonState = currentButtonState;
        if (mode == 0) {
            if (mode != lastMode) {
                lastMode = mode; // Update the last mode
                digitalWrite(LED_BUILTIN, HIGH); // Turn off the built-in LED
                for (int i = 0; i < config.LED_COUNT; i++) {
                    leds[i] = CRGB(0, 0, 0); // Turn off all LEDs
                }
                FastLED.show(); // Update the LED strip
                logg.debug("Modes: Switching to Adalight mode...");
                Serial.print("Ada\n"); // Send the command to switch to Adalight mode
            }
            adalight(); // Handle Adalight mode
        } else if (mode == 1) {
            if (lastMode != mode) {
                logg.debug("Modes: Switching to Config mode...");
                digitalWrite(LED_BUILTIN, LOW); // Turn on the built-in LED
                lastMode = mode; // Update the last mode
            }
            currentEffect = 1; // Reset the effect index
            manual(); // Handle effects
            commandHandler(); // Handle serial commands
        } else if (mode == 2) {
            if (mode != lastMode) {
                lastMode = mode; // Update the last mode
                logg.debug("Modes: Switching to Manual mode...");
                digitalWrite(LED_BUILTIN, HIGH); // Turn off the built-in LED
                for (int i = 0; i < config.LED_COUNT; i++) {
                    leds[i] = CRGB::White; // Turn off all LEDs
                }
                FastLED.show(); // Update the LED strip
            }
            currentEffect = 0; // Reset the effect index
            manual(); // Handle Manual mode
        }
    }
};
modesHandling modes; // Serial handling object

#ifndef DISABLE_IR
struct irFunctions {
    void init() {
        irrecv.enableIRIn();
    }
    void loop() {
        if (irrecv.decode(&results)) {
            logg.debug("IR: Received ir code: "+resultToHexidecimal(&results));
            process(resultToHexidecimal(&results));
            irrecv.resume();
        }
    }
    void checkRepeat() {

    }
    void process(String code) {
        long intCode = strtol(code.c_str(), NULL, 16);
        switch (intCode)
        {
        case 0xF7E817:
            logg.debug("IR: menu pressed");
            if (mode == 0) {
                mode = 2; // Switch to manual mode
                logg.debug("IR: Switching to manual mode...");
            } else if (mode == 1) {
                mode = 0; // Switch to Adalight mode
                logg.debug("IR: Switching to Adalight mode...");
            } else if (mode == 2) {
                mode = 0; // Switch to Adalight mode
                logg.debug("IR: Switching to Adalight mode...");
            }
        break;
        case 0xF700FF:  // Brightness +
            logg.debug("IR: Brightness + pressed");
            {
                uint8_t newBrightness = brightness + brightnessStep;
                if (newBrightness > brightnessMax) newBrightness = brightnessMax;
                led.setBrightness(newBrightness);
                logg.debug("IR: Brightness set to " + String(brightness));
            }
            break;
        case 0xF7807F:  // Brightness -
            logg.debug("IR: Brightness - pressed");
            {
                int newBrightness = brightness - brightnessStep;
                if (newBrightness < brightnessMin) newBrightness = brightnessMin;
                led.setBrightness(newBrightness);
                logg.debug("IR: Brightness set to " + String(brightness));
            }
            break;
        case 0xF7C03F:
            led.on(); // Turn on the LED strip
            logg.debug("IR: LED strip turned on");
        break;
        case 0xF740BF:
            led.off(); // Turn off the LED strip
            logg.debug("IR: LED strip turned off");
        default:logg.debug("IR: Unknown code received: "+code);break;
        }
    }
};
irFunctions ir;
#endif


#ifndef DISABLE_WIFI
struct webServer {
    struct app {
        void init() {
            server.on("/", HTTP_GET, []() {
                File file = LittleFS.open("/index.html", "r");
                if (!file) {
                    server.send(404, "text/plain", "File not found, check logs for more details.");
                    logg.error("WebServer: File not found: /index.html, check filesystem");
                    return;
                }
                server.streamFile(file, "text/html");
                file.close();
            });
            server.on("/info", HTTP_GET, []() {
                File file = LittleFS.open("/infos.html", "r");
                if (!file) {
                    server.send(404, "text/plain", "File not found, check logs for more details.");
                    logg.error("WebServer: File not found: /infos.html, check filesystem");
                    return;
                }
                server.streamFile(file, "text/html");
                file.close();
            });
            server.on("/leds", HTTP_GET, []() {
                String response = "LED Count: " + String(config.LED_COUNT) + "\n";
                response += "Max Current: " + String(config.MILLIAMPS) + " mA\n";
                response += "Max FPS: " + String(config.MAX_FPS) + "\n";
                server.send(200, "text/plain", response);
            });
            server.onNotFound([]() {
                server.send(404, "text/plain", "404 : Not Found");
            });
        }
    };
    struct api {
        void init() {
            server.on("/api/firmware", HTTP_GET, []() {
                JsonDocument doc;
                doc["version"] = ESPAURA_VERSION;
                doc["defaults"] = JsonObject();
                doc["defaults"]["LOG_LEVEL"] = LOG_LEVEL;
                doc["defaults"]["LED_COUNT"] = DEFAULT_NUM_LEDS;
                doc["defaults"]["MILLIAMPS"] = DEFAULT_MILLIAMPS;
                doc["defaults"]["MAX_FPS"] = DEFAULT_FRAMERATE;
                doc["defaults"]["SSID"] = DEFAULT_SSID;
                doc["vars"] = JsonObject();
                doc["vars"]["BRIGHTNESS_MAX"] = brightnessMax;
                doc["vars"]["BRIGHTNESS_MIN"] = brightnessMin;
                String response;
                serializeJson(doc, response);
                server.send(200, "application/json", response);
            });
            server.on("/api/config", HTTP_GET, []() {
                JsonDocument doc;
                doc["LED_COUNT"] = config.LED_COUNT;
                doc["MILLIAMPS"] = config.MILLIAMPS;
                doc["MAX_FPS"] = config.MAX_FPS;
                doc["SSID"] = config.SSID;
                String response;
                serializeJson(doc, response);
                server.send(200, "application/json", response);
            });
            server.on("/api/state", HTTP_GET, []() {
                JsonDocument doc;
                doc["MODE"] = mode;
                doc["BRIGHTNESS"] = brightness;
                doc["FPS"] = String(FastLED.getFPS());
                doc["POWER"] = ledPower;
                doc["COLOR"] = JsonObject();
                doc["COLOR"]["r"] = led.color.r;
                doc["COLOR"]["g"] = led.color.g;
                doc["COLOR"]["b"] = led.color.b;
                String response;
                serializeJson(doc, response);
                server.send(200, "application/json", response);
            });
            server.on("/api/mode", HTTP_POST, []() {
                if (!server.hasArg("plain")) {
                    server.send(400, "application/json", "{\"error\":\"Missing body\"}");
                    return;
                }
                String body = server.arg("plain");
                JsonDocument doc;
                DeserializationError error = deserializeJson(doc, body);
                if (error) {
                    server.send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
                    return;
                }
                if (!doc["mode"].is<int>()) {
                    server.send(400, "application/json", "{\"error\":\"Missing 'mode' field\"}");
                    return;
                }
                int newMode = doc["mode"];
                if (newMode < 0 || newMode > 2) {
                    server.send(400, "application/json", "{\"error\":\"Invalid mode value\"}");
                    return;
                }
                mode = newMode;
                server.send(200, "application/json", "{\"success\":true,\"mode\":" + String(mode) + "}");
            });
            server.on("/api/led/brightness", HTTP_POST, []() {
                if (!server.hasArg("plain")) {
                    server.send(400, "application/json", "{\"error\":\"Missing body\"}");
                    return;
                }
                String body = server.arg("plain");
                JsonDocument doc;
                DeserializationError error = deserializeJson(doc, body);
                if (error) {
                    server.send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
                    return;
                }
                if (!doc["brightness"].is<int>()) {
                    server.send(400, "application/json", "{\"error\":\"Missing 'brightness' field\"}");
                    return;
                }
                int newBrightness = doc["brightness"];
                if (newBrightness < brightnessMin || newBrightness > brightnessMax) {
                    server.send(400, "application/json", "{\"error\":\"Brightness out of range (" + String(brightnessMin) + "-" + String(brightnessMax) + ")\"}");
                    return;
                }
                led.setBrightness(newBrightness);
                server.send(200, "application/json", "{\"success\":true,\"brightness\":" + String(brightness) + "}");
            });
            server.on("/api/led/power", HTTP_POST, []() {
                if (!server.hasArg("plain")) {
                    server.send(400, "application/json", "{\"error\":\"Missing body\"}");
                    return;
                }
                String body = server.arg("plain");
                JsonDocument doc;
                DeserializationError error = deserializeJson(doc, body);
                if (error) {
                    server.send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
                    return;
                }
                if (!doc["power"].is<bool>()) {
                    server.send(400, "application/json", "{\"error\":\"Missing 'power' field\"}");
                    return;
                }
                ledPower = doc["power"];
                if (ledPower) {
                    led.on();
                } else {
                    led.off();
                }
                server.send(200, "application/json", "{\"success\":true,\"power\":" + String(ledPower) + "}");
            });
            server.on("/api/led/color", HTTP_POST, []() {
                if (!server.hasArg("plain")) {
                    server.send(400, "application/json", "{\"error\":\"Missing body\"}");
                    return;
                }
                String body = server.arg("plain");
                JsonDocument doc;
                DeserializationError error = deserializeJson(doc, body);
                if (error) {
                    server.send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
                    return;
                }
                if (!doc["r"].is<int>() || !doc["g"].is<int>() || !doc["b"].is<int>()) {
                    server.send(400, "application/json", "{\"error\":\"Missing 'r', 'g', or 'b' field\"}");
                    return;
                }
                int r = doc["r"];
                int g = doc["g"];
                int b = doc["b"];
                led.setColor(r, g, b);
                server.send(200, "application/json", "{\"success\":true,\"color\":{\"r\":" + String(r) + ",\"g\":" + String(g) + ",\"b\":" + String(b) + "}}");
            });
        }
    };
    api api;
    app app;
    void init() {
        app.init();
        api.init();
        server.begin(); // Start the web server
        logg.info("WebServer: Started on port 80");
    }
    void loop() {
        server.handleClient(); // Handle incoming client requests
    }
};


webServer web; // Web server object
#endif

// --------- //
// Main code //
// --------- //

// Starting code

void setup() {
    Serial.begin(SERIAL_RATE); // Initialize serial communication
    Serial.println("");
    logg.info("ESPAura: Initializing ESPAura");
    logg.info("ESPAura: Version " + String(ESPAURA_VERSION) + " - " + String(CURRENT_VERSION, HEX)); // Print version info
    logg.info("ESPAura: Thank you for using ESPAura !");
    logg.debug("Serial: initialized");
    pinMode(ACTION_BUTTON_PIN, INPUT_PULLUP); // Set the action button pin as input with pull-up resistor
    pinMode(LED_BUILTIN, OUTPUT); // Set the built-in LED pin as output
    digitalWrite(LED_BUILTIN, HIGH); // Turn off the built-in LED
    logg.debug("Pins: Pins initialized !");
    eeprom.init(); // Initialize EEPROM 
    led.init(); // Initialize LEDs
    logg.debug("LEDs: Initialized !");
    #ifndef DISABLE_FS
    lfs.init();
    #endif
    #ifndef DISABLE_IR
    ir.init();
    #endif
    #ifndef DISABLE_WIFI
    wifi.init(); // Initialize WiFi
    web.init(); // Initialize web server
    #ifndef DISABLE_MQTT
    mqtt.init(); // Initialize MQTT
    #endif
    #endif
}

void loop() {

    modes.loop(); // Handle serial modes
    #ifndef DISABLE_WIFI
    wifi.loop(); // Handle WiFi connection
    web.loop(); // Handle web server requests
    #ifndef DISABLE_MQTT
    mqtt.loop(); // Handle MQTT connection
    #endif
    #endif
    #ifndef DISABLE_IR
    ir.loop(); // Handle IR remote control
    #endif
}