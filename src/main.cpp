/**
 * ESPAura Firmware v1.0.0
 * 
 * A modular and efficient firmware for an ESP-based Ambilight system.
 * Designed for compatibility with HyperHDR via the Adalight protocol.
 * Allows manual configuration through serial commands and future WiFi support.
 * 
 * Developed by Esteladac | ESPAura Project
 * 
 * Used resources: 
 * - FastLED library for controlling LED strips
 * - IRremoteESP8266 library for IR remote control
 * - Using adalight from : https://github.com/Wifsimster/adalight_ws2812
 * - Using WLED Code to have some ideas how to code, I'm not copying it, just using it as a reference.
 * - ChatGPT for ideas suggestions and effect code generation, the code is not generated by it, it's written by me.
 * - Comments for all the file written by Github Copilot, I don't use it for code generation, just for comments.
 * 
 * Functionalities:
 * - Adalight mode for HyperHDR compatibility
 * - Configuration mode for setting LED count, max current, and max framerate
 * - Manual mode for direct LED control
 * - IR remote control support for switching modes
 * - EEPROM storage for configuration persistence
 * - Serial communication for configuration and debugging
 * - Built-in LED for status indication
 * - Improved error handling and logging
 * - Modular design for easy expansion and customization
 * 
 * Future improvements:
 * - WiFi support for remote configuration and control
 * - Additional effects and animations for LEDs
 * - User-friendly configuration interface
 * - Support for multiple LED types and configurations
 * - Integration with home automation systems
 * - Customizable presets for different lighting scenarios
 * - Support for different communication protocols (e.g., MQTT, HTTP API)
 * - Enhanced performance and efficiency
 * 
 * License:
 * ESPAura © 2025 by Esteladac is licensed under Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-nd/4.0/
 * 
*/

// ----------------------- //
// Disable functionalities //
// ----------------------- //

// #define DISABLE_IR
// #define DISABLE_EEPROM

// ------------- //
// Configuration //
// ------------- //

// Firmware infos

#define ESPAURA_VERSION "0.3.0" // Version of the firmware

// Firmware settings

#define LOG_LEVEL 3 // Log level (0 = no logs, 1 = info, 2 = warning, 3 = debug) warning: 0 level delete errors !

// Configuration 

#define SERIAL_RATE 921600 // Serial communication rate
#define MAX_SERIAL_WORDS 10 // Maximum number of words in a command
#define DEFAULT_NUM_LEDS 30 // Default number of LEDs
#define DEFAULT_MILLIAMPS 850 // Default max current in mA
#define DEFAULT_FRAMERATE 60 // Default max frames per second
#define MAX_LED_COUNT 800 // Maximum number of LEDs supported

// EEPROM settings

#define EEPROM_ENABLED true // Enable EEPROM storage
#define EEPROM_SIZE 512 // Size of the EEPROM in bytes

// Pin definitions

#define LED_PIN 15
#define INFO_LED_PIN 2
#define ACTION_BUTTON_PIN 13
#define IR_PIN 12

// --------- //
// Libraries //
// --------- //

#include <Arduino.h> // Arduino core library
#include <FastLED.h> // FastLED library for controlling LED strips
#ifndef DISABLE_EEPROM
    #include <EEPROM.h> // EEPROM library for storing configuration
    #define EEPROM_ENABLED true // Enable EEPROM storage
#else
    #define EEPROM_ENABLED false // Disable EEPROM storage
#endif
#ifndef DISABLE_IR
  #include <IRremoteESP8266.h>
  #include <IRrecv.h>
  #include <IRutils.h>
#endif

// ----------------------- //
// Constants and variables //
// ----------------------- //

#ifndef DISABLE_IR
    IRrecv irrecv(IR_PIN);
    decode_results results;
#endif

const uint8_t CURRENT_VERSION = 00000001; // Current version of the firmware in binary format

uint8_t mode = 0; // Current mode (0 = Adalight, 1 = Config, 3 = Manual)
uint8_t lastMode = 3; // Last mode used

int lastActionButtonState; // Last state of the action button

bool EEPROM_ERROR = false; // Flag to indicate if there was an EEPROM error

CRGB leds[MAX_LED_COUNT]; // Array to hold the LED colors

uint8_t prefix[] = {'A', 'd', 'a'}, hi, lo, chk, i; // Prefix for Adalight protocol

uint8_t brightness = 255; // Valeur initiale, à adapter selon ton projet
const uint8_t brightnessStep = 26; // Équivalent de 10% sur 255
const uint8_t brightnessMin = 16;
const uint8_t brightnessMax = 255;

uint8_t ledPower = 1;

// --------- //
// Functions //
// --------- //

// Config values and functions

struct configuration {
    int LED_COUNT; // Number of LEDs
    int MILLIAMPS; // Max current in mA
    uint8_t MAX_FPS; // Max frames per second
};
configuration config; // Configuration object

// Logging functions

struct logFunctions {
    void info(String message) {
        if (LOG_LEVEL >= 1) {
            Serial.println("[INFO] " + message);
        }
    }
    void error(String message) {
        if (LOG_LEVEL >= 1) {
            Serial.println("[ERROR] " + message);
        }
    }
    void warn(String message) {
        if (LOG_LEVEL >= 2) {
            Serial.println("[WARNING] " + message);
        }
    }
    void debug(String message) {
        if (LOG_LEVEL >= 3) {
            Serial.println("[DEBUG] " + message);
        }
    }
};
logFunctions logg; // Logging object

struct eepromFunctions {
    void save() {
        logg.debug("EEPROM: Saving configuration with size " + String(sizeof(config)) + " bytes");
        EEPROM.write(0, 0xAA); // Write a marker to indicate EEPROM is not empty
        EEPROM.put(1, CURRENT_VERSION); // Write the current version to EEPROM
        EEPROM.put(2, config); // Save the number of LEDs to EEPROM
        EEPROM.commit(); // Commit changes to EEPROM
        logg.debug("EEPROM: Values saved to EEPROM");
        logg.warn("System: Restarting ESP to apply changes...");
        ESP.restart(); // Restart the ESP to apply changes
    }
    void load() {
        EEPROM.get(2, config); // Read the number of LEDs from EEPROM
        logg.debug("EEPROM: Values read from EEPROM");
        logg.debug("EEPROM: LED Count: " + String(config.LED_COUNT) + " LEDs");
        logg.debug("EEPROM: Max Current: " + String(config.MILLIAMPS) + " mA");
    }
    void init() {
        EEPROM.begin(EEPROM_SIZE); // Initialize EEPROM
        logg.debug("EEPROM: Initialized with size " + String(EEPROM_SIZE) + " bytes");
        if (EEPROM_ENABLED) {
            if (EEPROM.read(0) == 0xFF) {
                logg.debug("EEPROM: empty, setting default values...");
                config.LED_COUNT = DEFAULT_NUM_LEDS; // Set default number of LEDs
                config.MILLIAMPS = DEFAULT_MILLIAMPS; // Set default max current
                config.MAX_FPS = DEFAULT_FRAMERATE; // Set default max FPS
                save(); // Save default values to EEPROM
            } else if (EEPROM.read(0) == 0xAA) {
                if (EEPROM.read(1) == CURRENT_VERSION) {
                    logg.debug("EEPROM: not empty, reading values...");
                    load(); // Read the number of LEDs from EEPROM
                } else {
                    logg.error("EEPROM: Invalid or outdated EEPROM data, setting default values...");
                    EEPROM_ERROR = true; // Set EEPROM error flag
                    config.LED_COUNT = DEFAULT_NUM_LEDS; // Set default number of LEDs
                    config.MILLIAMPS = DEFAULT_MILLIAMPS; // Set default max current
                    config.MAX_FPS = DEFAULT_FRAMERATE; // Set default max FPS
                    save(); // Save default values to EEPROM
                }
            }
        } else {
            logg.warn("EEPROM: disabled, using default values...");
            config.LED_COUNT = DEFAULT_NUM_LEDS; // Set default number of LEDs
            config.MILLIAMPS = DEFAULT_MILLIAMPS; // Set default max current
            config.MAX_FPS = DEFAULT_FRAMERATE; // Set default max FPS
        }
    }
    void clear() {
        logg.warn("EEPROM: Clearing EEPROM...");
        for (int i = 0; i < EEPROM_SIZE; i++) {
            EEPROM.write(i, 0xFF); // Effacement
        }
        EEPROM.commit(); // Commit des modifications
    
        // Vérification après effacement
        bool isCleared = true;
        for (int i = 0; i < EEPROM_SIZE; i++) {
            if (EEPROM.read(i) != 0xFF) {
                isCleared = false;
                break;
            }
        }
        if (isCleared) {
            logg.debug("EEPROM: Cleared successfully, resetting ESP...");
            delay(3000); // Wait for 3 seconds before restarting
            ESP.restart();
        } else {
            logg.error("EEPROM: Failed to clear properly!");
        }
    }
};

eepromFunctions eeprom; // EEPROM object

// Led functions

struct ledStruct {
    
    void init() {
        FastLED.addLeds<NEOPIXEL, LED_PIN>(leds, config.LED_COUNT); // Initialize the LED strip
        FastLED.setMaxRefreshRate(config.MAX_FPS); // Set max refresh rate
        FastLED.setMaxPowerInVoltsAndMilliamps(5, config.MILLIAMPS); // Set max power in volts and milliamps
    }
    void on() {
        ledPower = 1; // Turn on the LED strip
        FastLED.setBrightness(brightness); // Set brightness
    }
    void off() {
        ledPower = 0; // Turn off the LED strip
        FastLED.setBrightness(0); // Set brightness to 0
    }
};

ledStruct led; // LED object

// Effects functions


struct effects {
    unsigned long rainbowSwirl_previousMillis = 0;
    const long rainbowSwirl_interval = 20;  // Update every 20ms for smooth effect
    void rainbowSwirl() {
        static int rainbowSwirl_hueShift = 0;    // Start hue value for rainbow
        static int rainbowSwirl_swirlSpeed = 1; // Speed of the swirl
        unsigned long rainbowSwirl_currentMillis = millis();
      
        // Only update the LED colors every 'interval' milliseconds
        if (rainbowSwirl_currentMillis - rainbowSwirl_previousMillis >= rainbowSwirl_interval) {
          rainbowSwirl_previousMillis = rainbowSwirl_currentMillis;
      
          // Create the rainbow swirl effect
          for (int i = 0; i < config.LED_COUNT; i++) {
            // Calculate the hue based on position and time for a swirling effect
            int hue = (rainbowSwirl_hueShift + (i * 256 / config.LED_COUNT)) % 256;
            leds[i] = CHSV(hue, 255, 255); // Set the color of each LED based on hue
          }
      
          // Show the updated LED colors
          FastLED.show();
          
          // Adjust hueShift to make the swirl move
          rainbowSwirl_hueShift += rainbowSwirl_swirlSpeed;
        }
      }
};

effects effect; // Effects object

struct modesHandling {
    void catchSerial() {
        if (mode != lastMode) {
            lastMode = mode; // Update the last mode
            logg.debug("Serial: Switching to Config mode...");
        }
        while (Serial.available() > 0) {
            char incomingByte = Serial.read(); // Read the incoming byte
            Serial.print("Received: ");
            Serial.println(incomingByte); // Print the received byte
        }
    }
    unsigned long serialTimeout = 100; // Temps d'attente max en ms
    bool waitForSerialData(int bytesNeeded, unsigned long timeout) {
    unsigned long startTime = millis();
    while (Serial.available() < bytesNeeded) {
        if (millis() - startTime > timeout) {
        return false; // Timeout atteint
        }
        yield(); // Laisse l'ESP faire d'autres tâches (utile pour ESP8266/ESP32)
    }
    return true;
    }
    void commandHandler() {
        if (Serial.available() > 0) {  
            String command = Serial.readStringUntil('\n'); // Read the command until newline
            command.trim(); // Remove leading and trailing whitespace
            command.toLowerCase(); // Convert command to lowercase
            if (command.length() == 0) return; // Ignore empty commands
    
            int firstSpace = command.indexOf(' ');  
            String cmd = (firstSpace != -1) ? command.substring(0, firstSpace) : command;
    
            String args = (firstSpace != -1) ? command.substring(firstSpace + 1) : "";
            if (cmd == "set") {
                int secondSpace = args.indexOf(' ');  
                if (secondSpace == -1) {
                    logg.warn("Serial: Invalid set command format");
                    return; // Avoid processing an invalid command
                }
    
                String subCmd = args.substring(0, secondSpace);
                String subArgs = args.substring(secondSpace + 1);
    
                int value = subArgs.toInt();
                if (subCmd == "led") {
                    if (value > MAX_LED_COUNT) {
                        logg.warn("Serial: LED count exceeds maximum of "+String(MAX_LED_COUNT)+", setting to " + String(MAX_LED_COUNT));
                        config.LED_COUNT = MAX_LED_COUNT;
                    } else {
                        logg.info("Serial: Setting LED count to " + String(value));
                        config.LED_COUNT = value;
                    }
                } else if (subCmd == "color"){
                    for (int i = 0; i < config.LED_COUNT; i++) {
                        leds[i] = CRGB(value); // Set all LEDs to the specified color value
                    }
                    FastLED.show(); // Update the LED strip
                } else if (subCmd == "ma") {
                    logg.info("Serial: Setting max consumption to " + String(value) + " mA");
                    config.MILLIAMPS = value;
                } else if (subCmd == "fps") {
                    logg.info("Serial: Setting max framerate to " + String(value) + " fps");
                    if (value > 60) {
                        logg.warn("Serial: FPS value exceeds 60, the controller may encounter issues! Do you really need that?");
                    }
                    config.MAX_FPS = value;
                } else {
                    logg.warn("Serial: Unknown subcommand for 'set': " + subCmd);
                }
            } else if (cmd == "template") {
                //int value = args.toInt();

            } 
            else if (cmd == "save") {
                logg.info("Serial: Saving configuration...");
                eeprom.save();
            } 
            else if (cmd == "clear") {
                eeprom.clear();
            } 
            else {
                logg.debug("Serial: Unknown command: " + command+" use \"help\" for list of commands");
            }
        }    
    }
    void adalight() {
        static char configBuffer[7] = {0}; // Buffer pour stocker "config"

        // Vérifier si "config" est tapé dans le port série
        while (Serial.available()) {
          char c = Serial.read();
      
          // Décalage du buffer et ajout du nouveau caractère
          for (uint8_t j = 0; j < 5; j++) {
            configBuffer[j] = configBuffer[j + 1];
          }
          configBuffer[5] = c;
          configBuffer[6] = '\0';
      
          // Vérifier si "config" est dans le buffer
          if (strcmp(configBuffer, "config") == 0) {
            mode = 1;
            return;
          }
        }
      
        for (i = 0; i < sizeof prefix; ++i) {
          waitLoop:
          if (!waitForSerialData(1, serialTimeout)) return;
          if (prefix[i] == Serial.read()) continue;
          i = 0;
          goto waitLoop;
        }
      
        if (!waitForSerialData(3, serialTimeout)) return;
        hi = Serial.read();
        lo = Serial.read();
        chk = Serial.read();
      
        if (chk != (hi ^ lo ^ 0x55)) {
          i = 0;
          goto waitLoop;
        }
      
        memset(leds, 0, config.LED_COUNT * sizeof(struct CRGB));
      
        for (uint8_t i = 0; i < config.LED_COUNT; i++) {
          if (!waitForSerialData(3, serialTimeout)) return;
          byte r = Serial.read();
          byte g = Serial.read();
          byte b = Serial.read();
          leds[i] = CRGB(r, g, b);
        }
        FastLED.show();
    }
    void manual() {
        commandHandler(); // Handle serial commands
    }
    void loop() {
        if (digitalRead(ACTION_BUTTON_PIN) == LOW) { // Check if the action button is pressed
            if (lastActionButtonState == HIGH) { // If the last state was HIGH, it means the button was released
                logg.debug("Button: Action button pressed, switching mode...");
                if (mode == 0) {
                    mode = 1; // Switch to manual mode
                } else if (mode == 1) {
                    mode = 0; // Switch to Adalight mode
                } else if (mode == 2) {
                    mode = 0; // Switch to Adalight mode
                }
            }
        } else {
            lastActionButtonState = LOW; // Update the last state to LOW
        }
        if (mode == 0) {
            if (mode != lastMode) {
                lastMode = mode; // Update the last mode
                digitalWrite(LED_BUILTIN, HIGH); // Turn off the built-in LED
                for (int i = 0; i < config.LED_COUNT; i++) {
                    leds[i] = CRGB(0, 0, 0); // Turn off all LEDs
                }
                FastLED.show(); // Update the LED strip
                logg.debug("Modes: Switching to Adalight mode...");
                Serial.print("Ada\n"); // Send the command to switch to Adalight mode
            }
            adalight(); // Handle Adalight mode
        } else if (mode == 1) {
            if (lastMode != mode) {
                logg.debug("Modes: Switching to Config mode...");
                digitalWrite(LED_BUILTIN, LOW); // Turn on the built-in LED
                lastMode = mode; // Update the last mode
            }
            effect.rainbowSwirl(); // Handle effects in Config mode
            commandHandler(); // Handle serial commands
        } else if (mode == 2) {
            if (mode != lastMode) {
                lastMode = mode; // Update the last mode
                logg.debug("Modes: Switching to Manual mode...");
                digitalWrite(LED_BUILTIN, HIGH); // Turn on the built-in LED
            }
            manual(); // Handle Manual mode
        }
    }
};
modesHandling modes; // Serial handling object

#ifndef DISABLE_IR
struct irFunctions {
    void init() {
        irrecv.enableIRIn();
    }
    void loop() {
        if (irrecv.decode(&results)) {
            logg.debug("IR: Received ir code: "+resultToHexidecimal(&results));
            process(resultToHexidecimal(&results));
            irrecv.resume();
        }
    }
    void checkRepeat() {

    }
    void process(String code) {
        long intCode = strtol(code.c_str(), NULL, 16);
        switch (intCode)
        {
        case 0xF7E817:
            logg.debug("IR: menu pressed");
            if (mode == 0) {
                mode = 1; // Switch to manual mode
                logg.debug("IR: Switching to manual mode...");
            } else if (mode == 1) {
                mode = 0; // Switch to Adalight mode
                logg.debug("IR: Switching to Adalight mode...");
            } else if (mode == 2) {
                mode = 0; // Switch to Adalight mode
                logg.debug("IR: Switching to Adalight mode...");
            }
        break;
        case 0xF700FF:  // Brightness +
            logg.debug("IR: Brightness + pressed");
            if (brightness + brightnessStep <= brightnessMax) {
                brightness += brightnessStep;
            } else {
                brightness = brightnessMax;
                logg.debug("IR: Brightness already at maximum");
            }
            FastLED.setBrightness(brightness);
            logg.debug("IR: Brightness set to " + String(brightness));
        break;
        case 0xF7807F:  // Brightness -
            logg.debug("IR: Brightness - pressed");
            if (brightness >= brightnessMin + brightnessStep) {
                brightness -= brightnessStep;
            } else {
                brightness = brightnessMin;
                logg.debug("IR: Brightness already at minimum");
            }
            FastLED.setBrightness(brightness);
            logg.debug("IR: Brightness set to " + String(brightness));
        break;
        case 0xF7C03F:
            led.on(); // Turn on the LED strip
            logg.debug("IR: LED strip turned on");
        break;
        case 0xF740BF:
            led.off(); // Turn off the LED strip
            logg.debug("IR: LED strip turned off");
        default:logg.debug("IR: Unknown code received: "+code);break;
        }
    }
};
irFunctions ir;
#endif

// --------- //
// Main code //
// --------- //

// Starting code

void setup() {
    Serial.begin(SERIAL_RATE); // Initialize serial communication
    Serial.println("");
    logg.info("ESPAura: Initializing ESPAura v" + String(ESPAURA_VERSION));
    logg.info("ESPAura: Thank you for using ESPAura !");
    logg.debug("Serial: initialized");
    pinMode(ACTION_BUTTON_PIN, INPUT_PULLUP); // Set the action button pin as input with pull-up resistor
    pinMode(LED_BUILTIN, OUTPUT); // Set the built-in LED pin as output
    digitalWrite(LED_BUILTIN, HIGH); // Turn off the built-in LED
    logg.debug("Pins: Pins initialized !");
    eeprom.init(); // Initialize EEPROM 
    led.init(); // Initialize LEDs
    logg.debug("LEDs: Initialized !");
    #ifndef DISABLE_IR
    ir.init();
    #endif
}

void loop() {
    modes.loop(); // Handle serial modes
    #ifndef DISABLE_IR
    ir.loop();
    #endif
}